#!/usr/bin/env python3
"""
this is gadams' first cut attempt at creating a vdr, kept around for reference.
"""
import argparse
import json
import requests
from bs4 import BeautifulSoup

parser = argparse.ArgumentParser(description='Scrape the OpenJDK CVE site and return it in JSON format.')

parser.add_argument('--date', type=str, default='2023-01-17', help='The date to scrape CVEs for (YYYY-MM-DD)')
parser.add_argument('--apikey', type=str, default=None, help='Your NVD API key')

args = parser.parse_args()

# fetch the CVEs for the given date
url = 'https://openjdk.org/groups/vulnerability/advisories/' + args.date
r = requests.get(url)

soup = BeautifulSoup(r.text, 'html.parser')

# find the table with the CVEs
table = soup.find('table', attrs={'class': 'risk-matrix'})

# find all the rows in the table
rows = table.find_all('tr')

jsonData = []

sbomData = {
    'bomFormat': 'CycloneDX',
    'specVersion': '1.4',
    'version': 1,
    'vulnerabilities': [],
}
versions = []

# fetch CVE data from first td in each row
for row in rows:

    # find the versions in the first row
    header = row.find('th')
    if header is not None:
        component = header.find_next_sibling('th')
        if component.text == 'Component':
            score = component.find_next_sibling('th')
            while (score.find_next_sibling('th') is not None):
                versions.append(score.find_next_sibling('th').text)
                score = score.find_next_sibling('th')

    cve = row.find('td')
    if cve is not None:
        id = cve.text
        link = cve.find('a')['href']
        componentsTD = cve.find_next_sibling('td')
        components = componentsTD.text.replace('\n', '')
        scoreTD = componentsTD.find_next_sibling('td')
        score = scoreTD.text

        versionCheck = scoreTD
        
        # for version in versions:
        #     versionCheck = versionCheck.find_next_sibling('td')
        #     if versionCheck.text == 'â€¢':
        #         affected_versions.append(int(version))

        # make an API call to get the additional data for the CVE
        cveURL = 'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=' + id
        # pass API key as a header if you have one
        if args.apikey:
            headers = {'apiKey': args.apikey}
            cveRequest = requests.get(cveURL, headers=headers)
        else:
            cveRequest = requests.get(cveURL)

        # check status code to see if we were rate limited
        if cveRequest.status_code != 200:
            print('Error fetching CVE data for ' + id)
            print('This is likely rate limiting')
            print('Status code: ' + str(cveRequest.status_code))
            exit(1)
        cveData = cveRequest.json()

        affected_versions = []

        baseSeverity = cveData['vulnerabilities'][0]['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'].lower()
        vector = cveData['vulnerabilities'][0]['cve']['metrics']['cvssMetricV31'][0]['cvssData']['vectorString'].replace('CVSS:3.1/', '')
        description = cveData['vulnerabilities'][0]['cve']['descriptions'][0]['value']
        published = cveData['vulnerabilities'][0]['cve']['published']

        # filter through configurations until we find the ones that have the criteria matching opacle:jdk
        configurations = cveData['vulnerabilities'][0]['cve']['configurations']
        for configuration in configurations:
            for node in configuration['nodes']:
                if node['operator'] == 'OR':
                    for cpe in node['cpeMatch']:
                        if cpe['criteria'].startswith('cpe:2.3:a:oracle:jdk'):
                            # check if the version is 1.8.0
                            if cpe['criteria'].split(':')[5].startswith('1.8.0'):
                                cpeVersion = '8u' + cpe['criteria'].split(':')[6].replace('update', '')
                            elif cpe['criteria'].split(':')[5].startswith('1.7.0'):
                                cpeVersion = '7u' + cpe['criteria'].split(':')[6].replace('update', '')
                            else:
                                # extract the version from the CPE
                                cpeVersion = cpe['criteria'].split(':')[5]
                            affected_versions.append(cpeVersion)

        # Create JSON file
        jsonData.append({
            'id': id,
            'link': link,
            'components': components,
            'score': float(score),
            'affected_versions': affected_versions,
        })

        source = {
            'name': 'National Vulnerability Database',
            'link': link
        }

        sbomVersions = []

        for version in affected_versions:
            sbomVersions.append({
                'version': version,
                'status': 'affected'
            })

        # Create Cyclone DX SBOM file
        sbomData['vulnerabilities'].append({
            'id': id,
            'source': source,
            'ratings': [{
                'source': source,
                'score': float(score),
                'severity': baseSeverity,
                'method': 'CVSSv31',
                'vector': vector
            }],
            'description': description,
            'published': published,
            'affects': [{
                'ref': 'openjdk',
                'versions': sbomVersions
            }],
            'properties': {
                'name': 'Component',
                'value': components,
            }
        })

# create a JSON file for each version
with open('sboms/' + args.date + '.json', 'w') as f:
    json.dump(sbomData, f, indent=4)

# create a JSON file for each version
with open('json/' + args.date + '.json', 'w') as f:
    json.dump(jsonData, f, indent=4)
